
resources:
..> https://blog.algomaster.io/
..> 


Redis-server is the process or daemon that runs in teh background and listens for client connections.
Its is tha main component of redis, responsible for storing and managing data in mempry.

what is redis-cli:
The redis commands line interface(redis-cli) is a terminal program used to send commands to and read
to read replies from teh redis server.


what redisInsifgt:
redisInsight combines a graphical user interface with Redis cCLI to let you work with any Redis deployment.

KEYS IN REDIS:
Redis keys are binary safe, this means that you can use any binary sequence as a key,from a string like 'foo'
to teh content of a JPEG file.
.> the empty string also a valid key.
.> the maximum allowed key size is 512MB.
.> key should not be very long or very short.

strings:
 Redis strings are teh most basic redis data types, representing a sequences of bystes.

lists:
Redis lists are lists of strings sorted by insertion order.

set:
Redis sets are unordered collections of unique strings that act liek the sets from python, javs etc.

sorted sets:
Redis sorted sets are collections of unique strings that maintain order by each string's associated score

hash's:
redis hashes are record types models as collections of field-value pairs.Hashes are handy to represent objects.

Strams:
A redis stream is a data structure that acts like an append-only log.
Streams help record events in teh order they occur and then syndicate them for processing.


Basic Cnfiguration Commands:

config get * - This command is used to get all config settings;
config get requirepass- This command is used to get specific config setting.
config set requirepass value- This command is used to set specific config setting.

There is also a config file etc/redis/redis.conf which can be used to get all configurations and set configurations.


redis : 
.> the main application of the redis is the  caching of the data.{ for faster recovery. }
.> session storge :  redi sis used to store teh session id , 
note: the session data in the redis will be lost when the redis server is re-started , web browser is closed.

.> redis also supports the persistent storage of teh data { permanent storege } using the snapshopt, AOF, 
IN  this case te data will be stored in to teh disk and reloaded in to the memory when aware it needed { by the event of the re-start} .

..> Distributed looks : redis acts has the automic looks 
Distributed Locks in Redis mean using Redis to make sure that when multiple computers are working together,
only one computer can access/modify a resource at a time, safely and fast.

Redis can:

#) Create a lock using a simple key (example: "lock:account123").
Set an expiration (if something goes wrong, the lock will automatically expire).
Check if lock is held before allowing work.

#) Imagine you and your friend are editing the same document at the same time.
You lock the document when you are editing.
Until you finish and unlock it, your friend cannot edit.
After you unlock, your friend can edit.
Now imagine thousands of users and many servers are trying to edit the same data.
You need a central system to manage locks — Redis is perfect for this!


.> rate limiter : redis even atcs has the rate limiter

when the user logs in then his ip will ip made to set has te key , and when user keeps, on requesting 
then his ip address will be incremented and come paried to the default  rate set inside it , allow the request to reach teh DB only teh rate limits is with in the
controls, otherwise rejects here. and here teh key also set to expire after specfic 

.> gaming Leaderboard:j


redis snapshoots  concepts:

SNAP in Redis usually means Snapshot.
(Full name = RDB Snapshot.)

..> Snapshot = Saving a copy of your Redis data into a file.
So even if the server crashes or shuts down, you won't lose your data — because Redis saved a snapshot (copy) safely.


Term	                Meaning
RDB	                  Redis Database file (example: dump.rdb)
Snapshot	            A full copy of current data saved at a specific time
Persistence	          Keeping your in-memory (RAM) data safe on disk
RDB Snapshotting	    Redis will create .rdb file (compressed) and save your data periodically


Its use cases are here :

Redis saves a .rdb file
1) This .rdb file can be loaded back later
2) Safe even if server restarts/crashes


note point:
--------------- >
.> Redis automatically saves snapshots based on rules you set in your redis.conf file.

some redis commands are :
=============================== >
Commands:
Command	What it does
SAVE	Immediately save a snapshot (synchronous, blocking)
BGSAVE	Background Save (non-blocking, Redis still working)
LASTSAVE	See the last time Redis created a snapshot
CONFIG SET save	Set the rules for automatic snapshot saving
CONFIG GET dir	See where snapshots are being saved
CONFIG GET dbfilename	See the filename of the snapshot (default: dump.rdb)

ex: 
127.0.0.1:6379> SAVE
# Blocks Redis, saves snapshot immediately

127.0.0.1:6379> BGSAVE
# Starts saving in background, Redis keeps working

127.0.0.1:6379> LASTSAVE
# Shows last snapshot time (in UNIX timestamp)


Where is the Snapshot saved?

Linux: /var/lib/redis/dump.rdb
Windows: Where your Redis server is installed (in the bin folder)
You can change this using redis.conf settings:
dir /path/to/save
dbfilename mydata.rdb


ex: scenario 
Sachin is running a Redis server.
Every 5 minutes, if at least 10 changes happen, Redis automatically saves a snapshot to dump.rdb.
Tomorrow, Sachin's server crashes suddenly.
No problem — Sachin restarts Redis, and Redis loads the last snapshot automatically!

BASIC COMMANDS:

redis-cli --version


redis.service : to restart teh server
enable redis

sudo systemctl enable redis.service

sudo systemctl disable redis

sudo systemctl start redis
sudo systemctl stop redis
sudo systemctl restart redis
sudo systemctl status redis

sido service redis status

sudo snap enable redis
sudo snap restart redis
sudo snap services.


STRINGS RELATED COMMANDS:
+++++++++++++++++++++++++++++++++++++++++++++++++

keys *
set key <value>
get key
set name sachin
get name
del key 

// making the token for teh expirations 
exists <key_name> // to check for the all existing keys here
expire roll 10 // making an key with the expires time limt.

// renaming of the keys:
set name sachin
key *
rename <key_name> <new_key_name>
rename name namedemo;

// token settings
set token <nay _token_value>
get token
expire token 20
ttl token // to see how much time it is there here for teh token expiration.

// to get the length of the keys:
keys *
get name
strlen name

//  generally the set will override the keys but to make sure not to override the keys 
// we need to use the setnx

set id 11
get id // 11
set id 222
get id // 222 { keys are overriding here }

setnx state biahr // if alread key is there then it will make sure not to  make it over written other wise it will creaate the new key 
get state // bihar


// to delete all the keys we need use the

flushall //  by using this all the keys will be deleted form the redis.

// to crete teh inline multiple keys and values we use the 

mset name raj roll 90 class 9
keys * {name,roll,class}


setex state 20 bihar
get state
ttl state

// At the time of the key creation only if we want set teh expiration then we need to use the:

psetex state 5000 telangane
get state


incrby roll 2 // increment the value of the key by one1

decrby roll 3 // decrement teh value of the key by one1

 
LIST RELATED COMMANDS:
+++++++++++++++++++++++++++++++++

.> To push the elemnst into the list
LPUSH mylist a b c
{ here the last element which we send in the mylist defination will become the first element  of the list here}

LPUSH mylist "hello"
LPUSH mylist "world"
LPUSH mylist 0-1 { assinging the keys here }

op: "hello"
"world"

LPUSH students sai
LPUSH students manoj
LRANGE students 0-1

op: manoj
sai

: here we get the elemnst from te last to first 

.> to remove the elemts froms the list:
LPOP <KEY_NAME>
LPOP students // removes the first element
LPOP studensts 2 // removes the no of elements from the list 

LLEN students // to know the lenght of the  LIST 

LINDEX students <index> // To get the elements from the specific index 
LINDEX students 2


FLUSHALL // to remove the complete list  droping of that list 


.> to pass teh multiple elements into the list we use the

LPUSHX <key_name>  1 2 3 4  // here all  elements are stored in the list 
NOTE POINT HERE : the key which we are using need to be exists here early or previously only otherwise elemenst  will not be inserted here.

.> To insert to specific position we use the 
linsert <key_name> after <element>
linsert <key_name> before <element>


.> generally in the lpush the elements are stored in the reverse order like if the 1st elemt is stored at the last position 
but to over come this we use the:

rpush <key_name> elemt1 elemt2 elemt3 ...

rpush students sai ram manu
rpop // remove th elast element from the list 



SET RELATED COMMANDS:
+++++++++++++++++++++++++++++++++
It is an un-ordered collection of elements

.> to add elemnt in the set
sadd <key_name>  sai sonu ram

.> to get the elements from teh set we use the 
smembers <key_name>

.> 
ebven we try to give the duplicate numbers , but it only saves the unique numbers;
sadd students sai ram sonu sai

.> To ge teh length of the set we use the
scard <key _name>

.> To remove the particular element from teh set we use the :
smembers <key_name> <element_name>

.> To reomve any random elemnt form the set we use the
spop <key_name>

.> To remove tghe elements from teh set randomly with the count valuse:
spop <key_name> count_value
spop usersid 2

.> To see the difference between the twonsets we use the 
sdiff <key_name1>  <key_name2>

.> To merger teh two sets we use the 
sunion <key_name1> <key_name2>

.>  To get only common elements from the two sets we use the
sinter <key_name1> <key_name2>


.> To store the result after performing the union 
sunionstore finalresult1 result1 result2
sinterstore fianlresult2 result1 result2


.> TO check wheather any element  is belongs to the set or not we use:
sismember <key_name> <element>

.> 

SORTED SET RELATED COMMANDS:
+++++++++++++++++++++++++++++++++

.> zadd <key_name> <score> <value> // To add the elements here in to the sorted set we use this.

.> zrange  <key_name> range {0-0} // To see the values 

.> zrange <key_name> range withscores // To see the scores with the values we use this 

.> to the multiple scores we use the 

zadd run 200 sachin 120 dhoni 203 virat
zrange <kwy_name> range we use this 

NOTE :here the scores are automatically sorted here based on teh score values from the low to high.


.> To find the length of the sorted set we use the:
zcard <key_name> // to get the length we use this

.>To find the scores  in between we use this
zcount <key_name> 120 300 // this will find the runs made bu th eno of persons in between these numbers here and it will print the count here 

.> To find the scores of a particular person we use this:
zscore run virat

.>  To find the index of the particular person we use the:
zrun <key_name> virat

.> To get the range of scores between the given values withscores
zrangebyscore run  150 200 withscores

.> To delete the firt scores we use this 
zrem run 



HASH RELATED COMMANDS:
+++++++++++++++++++++++++++++++++


..> To set the hsets we use this 
hset <key_name> <field> <nalue>
ex: hset users:1 name ramu class 10 rollno 101 state telangana

..> To get all teh hash set users we use this
hgetall <key_name>
hgetall users:1

..> To get teh specific fields from the hset we  use this:
hget <key_name> <field>
hget users:1 name

..> To check for teh specific field is exists are not we use this
hexists <key_name>  <field>
hexists users:1 name

if exists we get the 1
else we get teh 0

...> To modify the particular field we use the 
hset users:1 name sachin 
// if name early =sai know will be changed to the sachin

..> to avoit this kind of overwritting we use this:
hsetnx users:1 <key_name> <value>

..> To delete the particular field from the keys we have 
hdel <key_name> <field_name>
hdel users:1 subjet

..> To get all the fields from teh key we use the
hkeys <key_name>
ex: hkeys users:1

..> in teh same way to get the values we use the
hvals <key_name>
ex: hvals users:1

..> To get the comlete length of teh hash set we use the
hlen <key_name>
hlen users:1

..> 























DIFFERENT CACHING STRATEGIES  explanation :
------------------------------------------------------------------------------------------------------------------------------ >

..> Caching means temporarily storing a copy of data so that future requests for that data can be served faster 
without fetching it again from the original source (like database, API, or server).


1. Cache Aside (Lazy Loading)
Idea: Only load into the cache when needed.

How it works:
App first checks the cache.
If the data is in the cache → return it.
If not → fetch from DB, store it in cache, and return it.

Pros:
Reduces memory usage (only needed data is cached).
Always fresh after write.

Cons:
First request is slow (DB fetch happens).

Diagram:
Request -> Cache Hit -> Return Data
Request -> Cache Miss -> Fetch from DB -> Save to Cache -> Return Data

------------------------------------------------------------------------------------------------

2. Write Through
Idea: Write to the cache and the database at the same time.

How it works:
When you update or insert data → first update cache, then update DB.

Diagram:
Write Request -> Cache + Database

Pros:
Cache always has the latest data.

Cons:
Write operations are slower (because both cache and DB must be updated).

------------------------------------------------------------------------------------------------

3. Write Back (Write Behind)
Idea: Write to cache only first, then asynchronously update the database later.

How it works:
Update cache immediately.
Batch update or delayed update to the database.

Diagram:
Write Request -> Cache
Later -> Cache flushes to Database

Pros:
Very fast writes.

Cons:
Risk of data loss if cache crashes before flushing to DB.

-----------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------

4. Read Through
Idea: Application never directly talks to DB. Cache itself fetches from DB on a miss.

How it works:
If data is in cache → return.
If not, cache itself fetches from DB and returns.

Diagram:
Request -> Cache (fetch if needed) -> Return Data

Pros:
Easy for the app — it just talks to the cache.

Cons:
Cache component becomes more complex (it must know how to fetch from DB).

-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------

5. Refresh Ahead (Auto Refresh)
Idea: Predict data expiration and refresh it before it expires.

How it works:
If you know data expires after 5 mins, the cache refreshes it at 4:30 mins.

Diagram:
Timer/Background Job -> Cache Refresh

Pros:
Almost zero cache misses.

Cons:
Can waste resources if data isn't actually needed again.


-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
